---
title: "TD 6 - Exercice 7 - Crabes fer √† cheval"
lang: fr
author: "Th√©o Leroy"
date: "5 decembre 2025"
params:
  question_courante: 0
format:
  live-html:
    code-background: true
    toc: true
    page-layout: full
webr:
  render-df: gt-interactive
  resources:
    - ./../data/crabs.txt
  packages:
      - dplyr
      - readr
      - ggplot2
      - GGally
      - tidyr
      - MASS
      - pscl
editor: 
  mode: source
  markdown: 
    wrap: 72
fig-align: center
filters: 
  - custom-callout
custom-callout:    
  answer:
    color: "#CCCCCC"
    icon: true
    icon-symbol: "üìù"
    appearance: "default"
    title: "Correction"
---

{{< include ./../_extensions/conditionnal.qmd >}}

{{< include ./../_extensions/r-wasm/live/_knitr.qmd >}}

Le jeu de donn√©es `crabs` contient l‚Äôobservation
de 173 limules femelles (Horshoe crabs). Il s‚Äôagit d‚Äôanimaux marins qui ressemblent √† des
crabes ayant une forme de fer √† cheval. Pour chaque limule femelle, on rel√®ve sa couleur
$\texttt{color}$ (cod√©e de 1 √† 4, du plus clair au plus sombre), sa largeur
$\texttt{width}$ , son poids $\texttt{weight}$ et $\texttt{satell}$ : le nombre
de limules m√¢les satellites (c‚Äôest √† dire accroch√©s √† la femelle). La
couleur est un signe de l‚Äô√¢ge de la limule, cette derni√®re ayant tendance
√† s‚Äôassombrir au cours du temps.

On cherche √† mod√©liser le nombre $\texttt{satell}$ en fonction des variables √† disposition.

## Question 1

Mettre en oeuvre un mod√®le log-lin√©aire de Poisson et un mod√®le binomial n√©gatif.
Evaluer leur qualit√©. On pourra en particulier discuter de la pertinence de consid√©rer
la variable $\texttt{color}$ comme une variable quantitative ou un facteur.

::: {.content-visible when-meta="is_answer_print_1"}
::: answer

On charge les donn√©es du fichier `crabs.txt` en {{< iconify logos:r-lang >}} sous forme de
`data.frame`.

::: {.panel-tabset group="language"}
### Base R

```{webr}
#| envir: baser
#| autorun: true
data_crabs <- read.csv(
  file = "data/crabs.txt",
  header = TRUE,
  sep = " ",
  quote = '"',
  colClasses = c("character", "factor", "numeric", "integer", "numeric")
)
data_crabs
```

### Tidyverse

```{webr}
#| envir: tdv
#| autorun: true
data_crabs <- readr::read_delim(
  file = "data/crabs.txt",
  col_names = c("color", "width", "satell", "weight"),
  col_types = readr::cols(
    readr::col_skip(),
    readr::col_factor(level = c("1", "2", "3", "4")),
    readr::col_number(),
    readr::col_integer(),
    readr::col_number()
  ),
  skip = 1,
  delim = " ",
  quote = '"'
)
data_crabs
```
:::

Le jeu de donn√©es contient bien 173 observations de limules femelles. La
variable cible est $\texttt{satell}$ le comptage de nombre de limules m√¢les
satellite. Les potentielles variables explicatives sont la couleur
$\texttt{color}$, $\texttt{width}$ et $\texttt{weight}$ le poids de la femelle.

La variable $\texttt{color}$ peut √™tre vu comme cat√©gorielle dans ce cas on
s'int√©ressera √† l'effet de passer d'une modalit√© √† une autre sur la
moyenne du nombre de limules m√¢les accroch√©es. Elle peut √™tre √©galement
vu comme quantitative et dans ce cas on s'int√©ressera √† l'effet de
l'assombrissement d'une unit√© sur la moyenne du nombre de limules m√¢les
accroch√©es.

On peut mener une courte √©tude descriptive.

::: {.panel-tabset group="language"}
### Base R

```{webr}
#| envir: baser
#| autorun: true
pairs(
  x = data_crabs[,c("satell", "color", "width", "weight")],
  main = "Matrice des nuages de points sur les donn√©es des limules"
)
```

### Tidyverse

```{webr}
#| envir: tdv
#| autorun: true
GGally::ggpairs(
    data = {
      data_crabs |>
        dplyr::mutate(color = as.integer(color)) |>
        dplyr::select(satell, color, width, weight)
    },
    columns  = c("satell", "color", "width", "weight"),
    title = "Matrice des nuages de points sur les donn√©es des limules",
    upper = list(continuous = "points"),
    lower = list(continuous = "cor")
)
```
:::

Graphiquement, on remarque que les variables $\texttt{width}$ et $\texttt{weight}$ sont
tr√®s corr√©l√©es. Pour √©viter des probl√®me de multicolin√©arit√© et
am√©liorer la qualit√© des estimations, on choisit de retirer la variable
$\texttt{width}$ dans les futures mod√®les.

On estime les diff√©rents mod√®les.

**Mod√®le log-lin√©aire de Poisson avec $\texttt{color}$ en `factor`**

::: {.panel-tabset group="language"}
### Base R

```{webr}
#| envir: baser
#| autorun: true
modele_poisson_factor <- glm(
  formula = satell ~ as.factor(color)+weight,
  family = poisson(),
  data = data_crabs
)
summary(modele_poisson_factor)
```

### Tidyverse

```{webr}
#| envir: tdv
#| autorun: true
modele_poisson_factor <- glm(
  formula = satell ~ as.factor(color)+weight,
  family = poisson(),
  data = data_crabs
)
summary(modele_poisson_factor)
```
:::

**Mod√®le log-lin√©aire de Poisson avec $\texttt{color}$ en `numeric`**

::: {.panel-tabset group="language"}
### Base R

```{webr}
#| envir: baser
#| autorun: true
modele_poisson_num <- glm(
  formula = satell ~ as.numeric(color)+weight,
  family = poisson(),
  data = data_crabs
)
summary(modele_poisson_num)
```

### Tidyverse

```{webr}
#| envir: tdv
#| autorun: true
modele_poisson_num <- glm(
  formula = satell ~ as.numeric(color)+weight,
  family = poisson(),
  data = data_crabs
)
summary(modele_poisson_num)
```
:::

**Mod√®le binomial n√©gatif avec $\texttt{color}$ en `factor`**

::: {.panel-tabset group="language"}
### Base R

```{webr}
#| envir: baser
#| autorun: true
modele_nb_factor <- MASS::glm.nb(
  formula = satell ~ as.factor(color)+weight,
  data = data_crabs
)
summary(modele_nb_factor)
```

### Tidyverse

```{webr}
#| envir: tdv
#| autorun: true
modele_nb_factor <- MASS::glm.nb(
  formula = satell ~ as.factor(color)+weight,
  data = data_crabs
)
summary(modele_nb_factor)
```
:::

**Mod√®le binomial n√©gatif avec $\texttt{color}$ en `numeric`**

::: {.panel-tabset group="language"}
### Base R

```{webr}
#| envir: baser
#| autorun: true
modele_nb_num <- MASS::glm.nb(
  formula = satell ~ as.numeric(color)+weight,
  data = data_crabs
)
summary(modele_nb_num)
```

### Tidyverse

```{webr}
#| envir: tdv
#| autorun: true
modele_nb_num <- MASS::glm.nb(
  formula = satell ~ as.numeric(color)+weight,
  data = data_crabs
)
summary(modele_nb_num)
```
:::

Pour la mod√©lisation avec loglin√©aire de Poisson, la d√©viance est
beaucoup plus √©lev√©e que le nombre de degr√© de libert√© m√™me pour le cas
le plus favorable ou $\texttt{color}$ est int√©gr√© comme variable quantitative. Il
ya sans doute un probl√®me de surdispersion, l'hypoth√®se que la moyenne
est √©gale √† la variance dans la mod√©lisation de Poisson n'est sans doute
pas v√©rifi√©e.

L'ajustement avec le mod√®le binomial n√©gatif est meilleur (en regardant
les d√©viances et l'AIC) surtout en consid√©rant $\texttt{color}$ comme
quantitative qui ne semble pas significative au final.

On peut √©tudier la distribution empirique de $\texttt{satell}$ par rapport √† la
distribution pr√©dite par le mod√®le `modele_nb_num` pour analyser la
qualit√© des pr√©dictions du mod√®le.

::: {.panel-tabset group="language"}
### Base R

```{webr}
#| envir: baser
#| autorun: true
comptage_empirique <- sapply(
  X = 0:15,
  FUN = function(k){
    sum(data_crabs$satell == k)
  }
)
comptage_predit <- sapply(
  X = 0:15,
  FUN = function(k){
    sum(
      sapply(
        X = predict(modele_nb_num, type = "response"),
        FUN = function(mu){dnbinom(x = k,size = modele_nb_num$theta, mu = mu)}
      )
    )
  }
)
plot(
  x = 0:15,
  y = comptage_empirique,
  col = "blue",
  xlab = "Nombre de limules m√¢les satellite pour une femelle",
  ylab = "Nombre de limules femelles"
)
points(x = 0:15, y = comptage_predit, col = "red")
legend(
  "topright",             
  legend = c(
    "Donn√©es empiriques",
    "Pr√©diction du mod√®le sur le jeu de donn√©es"
  ), 
  col = c("blue", "red"),    
  pch = 1
) 
grid()
```

### Tidyverse

```{webr}
#| envir: tdv
#| autorun: true
comptage_empirique <- sapply(
  X = 0:15,
  FUN = function(k){
    sum(data_crabs$satell == k)
  }
)
comptage_predit <- sapply(
  X = 0:15,
  FUN = function(k){
    sum(
      sapply(
        X = predict(modele_nb_num, type = "response"),
        FUN = function(mu){dnbinom(x = k,size = modele_nb_num$theta, mu = mu)}
      )
    )
  }
)

# Cr√©ation d'un dataframe combinant les donn√©es empiriques et pr√©dites
data_plot <- data.frame(
  Nombre_satellites = rep(0:15, 2),
  Nombre_femelles = c(comptage_empirique, comptage_predit),
  Source = rep(c("Empirique", "Pr√©dite"), each = length(0:15))
)

# Cr√©ation du graphique avec ggplot2
ggplot2::ggplot(
  data = data_plot,
  mapping = ggplot2::aes(x = Nombre_satellites, y = Nombre_femelles, color = Source)
) +
  ggplot2::geom_point() +                  
  ggplot2::scale_color_manual(
    values = c("Empirique" = "blue", "Pr√©dite" = "red"),
    labels = c("Donn√©es empiriques", "Pr√©diction du mod√®le")
  ) +
  ggplot2::labs(
    title = "Nombre de limules m√¢les satellites par femelle",
    x = "Nombre de limules m√¢les satellites",
    y = "Nombre de limules femelles",
    color = "Source"
  ) +
  ggplot2::theme_minimal() +                       
  ggplot2::theme(
    legend.position = "top",            
    plot.title = element_text(hjust = 0.5) 
  )
```
:::

On voit que la mod√©lisation ne permet pas de pr√©dire convenablement le
nombre de femelles lorsque le nombre de m√¢les satellite est faible.

:::
:::

## Question 2

Am√©liorer la mod√©lisation en tenant compte de l‚Äôinflation de z√©ros.

::: {.content-visible when-meta="is_answer_print_2"}
::: answer

On peut essayer de mettre en place un mod√®le √† inflation de z√©ros dans
le mod√®le binomial n√©gatif pour am√©liorer les pr√©dictions. Pour se
faire, on utilise la fonction `zeroinfl` du package `pscl`.

::: {.panel-tabset group="language"}
### Base R

```{webr}
#| envir: baser
#| autorun: true
?pscl::zeroinfl()
```

### Tidyverse

```{webr}
#| envir: tdv
#| autorun: true
?pscl::zeroinfl()
```
:::

::: {.panel-tabset group="language"}
### Base R

```{webr}
#| envir: baser
#| autorun: true
modele_zeroinfl <- pscl::zeroinfl(
  formula = satell ~ weight + as.numeric(color) | weight + as.numeric(color),
  data = data_crabs,
  dist = "negbin"
)
summary(modele_zeroinfl)
```

### Tidyverse

```{webr}
#| envir: tdv
#| autorun: true
modele_zeroinfl <- pscl::zeroinfl(
  formula = satell ~ weight + as.numeric(color) | weight + as.numeric(color),
  data = data_crabs,
  dist = "negbin"
)
summary(modele_zeroinfl)
```
:::

::: {.panel-tabset group="language"}
### Base R

```{webr}
#| envir: baser
#| autorun: true
comptage_empirique <- sapply(
  X = 0:15,
  FUN = function(k){
    sum(data_crabs$satell == k)
  }
)
comptage_predit <- colSums(predict(modele_zeroinfl, type = "prob", at = 0:15))
plot(
  x = 0:15,
  y = comptage_empirique,
  col = "blue",
  xlab = "Nombre de limules m√¢les satellite pour une femelle",
  ylab = "Nombre de limules femelles"
)
points(x = 0:15, y = comptage_predit, col = "red")
legend(
  "topright",             
  legend = c(
    "Donn√©es empiriques",
    "Pr√©diction du mod√®le sur le jeu de donn√©es"
  ), 
  col = c("blue", "red"),    
  pch = 1
) 
grid()
```

### Tidyverse

```{webr}
#| envir: tdv
#| autorun: true
comptage_empirique <- sapply(
  X = 0:15,
  FUN = function(k){
    sum(data_crabs$satell == k)
  }
)
comptage_predit <- colSums(predict(modele_zeroinfl, type = "prob", at = 0:15))

# Cr√©ation d'un dataframe combinant les donn√©es empiriques et pr√©dites
data_plot <- data.frame(
  Nombre_satellites = rep(0:15, 2),
  Nombre_femelles = c(comptage_empirique, comptage_predit),
  Source = rep(c("Empirique", "Pr√©dite"), each = length(0:15))
)

# Cr√©ation du graphique avec ggplot2
ggplot2::ggplot(
  data = data_plot,
  mapping = ggplot2::aes(x = Nombre_satellites, y = Nombre_femelles, color = Source)
) +
  ggplot2::geom_point() +                  
  ggplot2::scale_color_manual(
    values = c("Empirique" = "blue", "Pr√©dite" = "red"),
    labels = c("Donn√©es empiriques", "Pr√©diction du mod√®le")
  ) +
  ggplot2::labs(
    title = "Nombre de limules m√¢les satellites par femelle",
    x = "Nombre de limules m√¢les satellites",
    y = "Nombre de limules femelles",
    color = "Source"
  ) +
  ggplot2::theme_minimal() +                       
  ggplot2::theme(
    legend.position = "top",            
    plot.title = element_text(hjust = 0.5) 
  )
```
:::

La r√©partition des petites valeurs est mieux mod√©lis√©e.

:::
:::