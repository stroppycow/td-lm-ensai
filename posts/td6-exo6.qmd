---
title: "TD 6 - Exercice 6 - Fourmis"
lang: fr
author: "Th√©o Leroy"
date: "5 decembre 2025"
params:
  question_courante: 0
format:
  live-html:
    code-background: true
    toc: true
    page-layout: full
webr:
  render-df: gt-interactive
  resources:
    - ./../data/Fourmis.txt
  packages:
      - dplyr
      - readr
      - ggplot2
      - gridExtra
      - tidyr
      - MASS
editor: 
  mode: source
  markdown: 
    wrap: 72
fig-align: center
filters: 
  - custom-callout
custom-callout:    
  answer:
    color: "#CCCCCC"
    icon: true
    icon-symbol: "üìù"
    appearance: "default"
    title: "Correction"
---

{{< include ./../_extensions/conditionnal.qmd >}}
{{< include ./../_extensions/r-wasm/live/_knitr.qmd >}}

Le but de l‚Äô√©tude est d‚Äô√©tudier la diversit√© des fourmis
sur le site exp√©rimental des Nourragues en Guyane Fran√ßaise.
On a pr√©lev√© 1 m¬≤ de liti√®re en plusieurs endroits de 4 for√™ts diff√©rentes
(la for√™t de plateau $\texttt{GPWT}$, la foret de liane $\texttt{FLWT}$,
la foret de transition $\texttt{FTWT}$,
et la for√™t d‚ÄôInselberg $\texttt{INWT}$).
Chaque √©chantillon a √©t√© pes√© (variable $\texttt{Weight}$) et le nombre
d‚Äôesp√®ces diff√©rentes pr√©sentes dans l‚Äô√©chantillon a √©t√©
relev√© (variable $\texttt{Effectifs}$). Enfin les conditions de recueil
(humides ou s√®ches, variable  $\texttt{Conditions}$) ont √©t√© not√©es pour
tester leur influence sur la pr√©sence des fourmis.

## Question 1

Importer les donn√©es sous {{< iconify logos:r-lang >}} et transformer
les variables cat√©gorielles en facteur.

::: {.content-visible when-meta="is_answer_print_1"}
::: answer 

On charge les donn√©es du fichier `Fourmis.txt` en {{< iconify logos:r-lang >}} sous forme de
`data.frame`.

::: {.panel-tabset group="language"}
### Base R

```{webr}
#| envir: baser
#| autorun: true
data_fourmis <- read.csv(
  file = 'data/Fourmis.txt',
  sep = ",",
  header = TRUE,
  colClasses = c("integer", "numeric", "factor", "factor")
)
data_fourmis
```

### Tidyverse

```{webr}
#| envir: tdv
#| autorun: true
data_fourmis <- readr::read_delim(
  file = "data/Fourmis.txt",
  col_types = readr::cols(
    readr::col_integer(),
    readr::col_number(),
    readr::col_factor(level = c("FLWT", "FTWT", "GPWT", "INWT")),
    readr::col_factor(level = c("Dry", "Wet"))
  ),
  delim = ","
)
data_fourmis
```
:::

La variable $\texttt{Effectifs}$ correspondant au nombre d'esp√®ces diff√©rentes de
fourmis dans l'√©chantillon pr√©lev√© est une variable de comptage. On
l'importe comme `integer`.

La variable $\texttt{Weight}$ contient le poids des √©chantillons.C'est une
variable quantitative, on l'importe en `numeric`.

La variable $\texttt{Site}$ indique la provenance des diff√©rents √©chantillons
($\texttt{GPWT}$ : for√™t de plateau, $\texttt{FLWT}$ for√™t de lianes, $\texttt{FTWT}$ for√™t de
transition, et $\texttt{INWT}$ for√™t d'Iselberg). C'est une variable
cat√©gorielle. On l'importe en `factor`.

La variable $\texttt{Conditions}$ nous renseigne sur les conditions de recueil de
l'√©chantillon. C'est une variable cat√©gorielle avec deux modalit√©s :
$\texttt{Dry}$ (sec) et $\texttt{Wet}$ (humide) qu'on importe donc en `factor`.

:::

:::

## Question 2

Effectuer une petite √©tude descriptive pour identifier un lien √©ventuel entre le nombre
d‚Äôesp√®ces observ√© et les autres variables √† disposition.

::: {.content-visible when-meta="is_answer_print_2"}
::: answer

**Lien entre $\texttt{Weight}$ et $\texttt{Effectifs}$**

::: {.panel-tabset group="language"}
#### Base R

```{webr}
#| envir: baser
#| autorun: true
plot(
  x = data_fourmis$Weight,
  y = data_fourmis$Effectifs, 
  xlab = "Poids de l'√©chantillon", 
  ylab = "Nombre d'esp√®ces diff√©rentes",
)
grid()
```

#### Tidyverse

```{webr}
#| envir: tdv
#| autorun: true
ggplot2::ggplot(
  data = data_fourmis,
  mapping = ggplot2::aes(x = Weight, y = Effectifs)
) +
  ggplot2::geom_point() +
  ggplot2::labs(
    x = "Poids de l'√©chantillon",
    y = "Nombre d'esp√®ces diff√©rentes"
  ) +
  ggplot2::theme_light() 
```
:::

Ce nuage de point ne permet pas de mettre en √©vidence un lien entre le
poids de l'√©chantillon et l'effectif de fourmis pr√©sent.

::: {.panel-tabset group="language"}
#### Base R

```{webr}
#| envir: baser
#| autorun: true
par(mfrow = c(2,2))
lapply(
  X = levels(data_fourmis$Site),
  FUN = function(site){
    plot(
      x = data_fourmis[data_fourmis$Site == site, "Weight"],
      y = data_fourmis[data_fourmis$Site == site, "Effectifs"],
      xlab = "Poids de l'√©chantillon", 
      ylab = "Nombre d'esp√®ces diff√©rentes",
      main = site
    )
    grid()
  }
) |> invisible()
```

#### Tidyverse

```{webr}
#| envir: tdv
#| autorun: true
par(mfrow = c(2,2))
g <- lapply(
  X = levels(data_fourmis$Site),
  FUN = function(site){
    ggplot2::ggplot(
      data = data_fourmis |> dplyr::filter(Site == site),
      mapping = ggplot2::aes(x = Weight, y = Effectifs, main = site)
    ) +
      ggplot2::geom_point() +
      ggplot2::labs(
        x = "Poids de l'√©chantillon",
        y = "Nombre d'esp√®ces diff√©rentes"
      ) +
      ggplot2::ggtitle(label= site) + 
      ggplot2::theme_light() 
  }
)
gridExtra::grid.arrange(grobs = g, layout_matrix = matrix(1:4, ncol = 2))
```
:::

En distinguant par type de for√™t un lien croissant semble exister pour
les for√™ts $\texttt{FLWT}$ et $\texttt{GPWT}$.

**Lien entre $\texttt{Site}$ et $\texttt{Effectifs}$**

::: {.panel-tabset group="language"}
#### Base R

```{webr}
#| envir: baser
#| autorun: true
boxplot(
  Effectifs ~ Site,
  data = data_fourmis,
  main = "Distribution du nombre d'esp√®ces de fourmis en fonction du site de pr√©l√®vement"
)
```

#### Tidyverse

```{webr}
#| envir: tdv
#| autorun: true
ggplot2::ggplot(
  data = data_fourmis,
  mapping = ggplot2::aes(x = Site, y = Effectifs)
) +
  ggplot2::geom_boxplot() +
  ggplot2::labs(
    title = "Distribution du nombre d'esp√®ces de fourmis en fonction du site de pr√©l√®vement"
  ) +
  ggplot2::theme_minimal()
```
:::

Un lien semble exister entre le type de for√™t et le nombre d'esp√®ces de
fourmis.

**Lien entre $\texttt{Conditions}$ et $\texttt{Effectifs}$**

::: {.panel-tabset group="language"}
#### Base R

```{webr}
#| envir: baser
#| autorun: true
boxplot(
  Conditions ~ Effectifs,
  data = data_fourmis,
  main = "Distribution du nombre d'esp√®ces de fourmis en fonction des conditions de recueil"
)
```

#### Tidyverse

```{webr}
#| envir: tdv
#| autorun: true
ggplot2::ggplot(
  data = data_fourmis,
  mapping = ggplot2::aes(x = Conditions, y = Effectifs)
) +
  ggplot2::geom_boxplot() +
  ggplot2::labs(
    title = "Distribution du nombre d'esp√®ces de fourmis en fonction des conditions de recueil"
  ) +
  ggplot2::theme_minimal()
```
:::

Aucune relation ne semble exister entre les conditions de recueil et le
nombre d'esp√®ces de fourmis.

:::

:::

## Question 3

Mod√©liser par un mod√®le log-lin√©aire de Poisson la variable $\texttt{Effectifs}$ en fonction
de toutes les variables √† disposition, en incluant toutes leurs interactions possibles.
Analyser la sortie du mod√®le.

::: {.content-visible when-meta="is_answer_print_3"}
::: answer

Le mod√®le log-lin√©aire de Poisson de la variables $\texttt{Effectifs}$ en
fonction de toutes les variables √† disposition s'√©crit :

$$
\begin{align*}
\texttt{Effectifs}&|(\texttt{Weight}, \texttt{Site},\texttt{Conditions}) \sim \mathcal{P}(\lambda(\texttt{Weight}, \texttt{Site},\texttt{Conditions}))
\end{align*}
$$

avec

$\textrm{log}\left(\lambda(\texttt{Weight}, \texttt{Site},\texttt{Conditions})\right)$

$$
\begin{align*}
= &\ \ \ \ \ \beta_0 \\ 
&+ \beta_1\texttt{Weight} \\
&+ \beta_2\textbf{1}_{\texttt{Site}=\texttt{FTWT}}+\beta_3\textbf{1}_{\texttt{Site}=\texttt{GPWT}}+\beta_4\textbf{1}_{\texttt{Site}=\texttt{INWT}} \\
&+ \beta_5\textbf{1}_{\texttt{Conditions}=\texttt{Wet}} \\
&+ \beta_6\texttt{Weight}\textbf{1}_{\texttt{Site}=\texttt{FTWT}}+\beta_7\texttt{Weight}\textbf{1}_{\texttt{Site}=\texttt{GPWT}}+\beta_8\texttt{Weight}\textbf{1}_{\texttt{Site}=\texttt{INWT}} \\
&+ \beta_9\texttt{Weight}\textbf{1}_{\texttt{Conditions}=\texttt{Wet}} \\
&+ \beta_{10}\textbf{1}_{\texttt{Site}=\texttt{FTWT}}\textbf{1}_{\texttt{Conditions}=\texttt{Wet}}+\beta_{11}\textbf{1}_{\texttt{Site}=\texttt{GPWT}}\textbf{1}_{\texttt{Conditions}=\texttt{Wet}}+\beta_{12}\textbf{1}_{\texttt{Site}=\texttt{INWT}}\textbf{1}_{\texttt{Conditions}=\texttt{Wet}} \\ 
&+ \beta_{13}\texttt{Weight}\textbf{1}_{\texttt{Site}=\texttt{FTWT}}\textbf{1}_{\texttt{Conditions}=\texttt{Wet}} +\beta_{14}\texttt{Weight}\textbf{1}_{\texttt{Site}=\texttt{GPWT}}\textbf{1}_{\texttt{Conditions}=\texttt{Wet}}+\beta_{15}\texttt{Weight}\textbf{1}_{\texttt{Site}=\texttt{INWT}}\textbf{1}_{\texttt{Conditions}=\texttt{Wet}}  \\
\end{align*}
$$

Il y a 16 param√®tres √† estimer.

On peut repr√©senter la mod√©lisation de
$\textrm{log}\left(\lambda(\texttt{Weight}, \texttt{Site},\texttt{Conditions})\right)$
dans un tableau √† double entr√©e.

|   | $\texttt{Conditions}=\texttt{"Dry"}$ | $\texttt{Conditions}=\texttt{"Wet"}$ |
|------------------------|------------------------|------------------------|
| $\texttt{Site}=\texttt{"FLWT"}$ | $\beta_0+\beta_1\texttt{Weight}$ | $\beta_0+\beta_5+(\beta_1+\beta_9)\texttt{Weight}$ |
| $\texttt{Site}=\texttt{"FTWT"}$ | $\beta_0+\beta_2+(\beta_1+\beta_{6})\texttt{Weight}$ | $\beta_0+\beta_2+\beta_5+\beta_{10}+(\beta_1+\beta_6+\beta_9+\beta_{13})\texttt{Weight}$ |
| $\texttt{Site}=\texttt{"GPWT"}$ | $\beta_0+\beta_3+(\beta_1+\beta_{7})\texttt{Weight}$ | $\beta_0+\beta_3+\beta_5+\beta_{11}+(\beta_1+\beta_7+\beta_9+\beta_{14})\texttt{Weight}$ |
| $\texttt{Site}=\texttt{"INWT"}$ | $\beta_0+\beta_4+(\beta_1+\beta_{8})\texttt{Weight}$ | $\beta_0+\beta_4+\beta_5+\beta_{12}+(\beta_1+\beta_8+\beta_9+\beta_{15})\texttt{Weight}$ |

On ajuste le mod√®le avec la fonction `glm`.

::: {.panel-tabset group="language"}
### Base R

```{webr}
#| envir: baser
#| autorun: true
modele_q3 <- glm(
  formula = Effectifs ~ Weight*Site*Conditions,
  family = poisson(),
  data = data_fourmis
)
summary(modele_q3)
```

### Tidyverse

```{webr}
#| envir: tdv
#| autorun: true
modele_q3 <- glm(
  formula = Effectifs ~ Weight*Site*Conditions,
  family = poisson(),
  data = data_fourmis
)
summary(modele_q3)
```
:::

Une analyse rapide des r√©sultats de la sortie donn√©e par la fonction
`summary` met en √©vidence de nombreux coefficients non significatifs.
Cependant, l‚Äôinteraction triple semblerait pertinente car certains
coefficients associ√©s sont significatifs au seuil 5 %. Ainsi, le
coefficient associ√© √† la variable $\texttt{Weight}$ ne varie pas de mani√®re
significative lorsqu‚Äôon consid√®re uniquement le site ou les conditions
s√©par√©ment (cf. interactions doubles) mais il semble varier quand on
prend en compte √† la fois $\texttt{Site}$ et $\texttt{Conditions}$.

:::

:::

## Question 4

En utilisant la fonction `step`, effectuer une s√©lection stepwise backward du meilleur
sous-mod√®le du mod√®le pr√©c√©dent selon le crit√®re AIC, puis selon le crit√®re BIC.
Effectuer de m√™me une s√©lection stepwise forward. Comparer les choix obtenus.

::: {.content-visible when-meta="is_answer_print_4"}
::: answer

On met en place les diff√©rentes proc√©dure de s√©lction demand√©es

**Backward avec l'AIC**

::: {.panel-tabset group="language"}
### Base R

```{webr}
#| envir: baser
#| autorun: true
modele_q4_sel_backward_aic <- step(
  object = modele_q3,
  trace = 0,
  direction = "backward"
)
summary(modele_q4_sel_backward_aic)
```

### Tidyverse

```{webr}
#| envir: tdv
#| autorun: true
modele_q4_sel_backward_aic <- step(
  object = modele_q3,
  trace = 0,
  direction = "backward"
)
summary(modele_q4_sel_backward_aic)
```
:::

**Backward avec le BIC**

::: {.panel-tabset group="language"}
### Base R

```{webr}
#| envir: baser
#| autorun: true
modele_q4_sel_backward_bic <-step(
  object = modele_q3,
  trace = 0,
  direction = "backward",
  k = log(nrow(data_fourmis))
)
summary(modele_q4_sel_backward_bic)
```

### Tidyverse

```{webr}
#| envir: tdv
#| autorun: true
modele_q4_sel_backward_bic <- step(
  object = modele_q3,
  trace = 0,
  direction = "backward",
  k = log(nrow(data_fourmis))
)
summary(modele_q4_sel_backward_bic)
```
:::

**Foreward avec l'AIC**

::: {.panel-tabset group="language"}
### Base R

```{webr}
#| envir: baser
#| autorun: true
modele_q4_sel_forward_aic <- step(
  object = glm(
    formula = Effectifs ~ 1,
    family = poisson(),
    data = data_fourmis
  ),
  scope = list(upper = Effectifs ~ Weight*Site*Conditions),
  trace = 0,
  direction = "forward"
)
summary(modele_q4_sel_forward_aic)
```

### Tidyverse

```{webr}
#| envir: tdv
#| autorun: true
modele_q4_sel_forward_aic <- step(
  object = glm(
    formula = Effectifs ~ 1,
    family = poisson(),
    data = data_fourmis
  ),
  scope = list(upper = Effectifs ~ Weight*Site*Conditions),
  trace = 0,
  direction = "forward"
)
summary(modele_q4_sel_forward_aic)
```
:::

**Foreward avec le BIC**

::: {.panel-tabset group="language"}
### Base R

```{webr}
#| envir: baser
#| autorun: true
modele_q4_sel_forward_bic <- step(
  object = glm(
    formula = Effectifs ~ 1,
    family = poisson(),
    data = data_fourmis
  ),
  scope = list(upper = Effectifs ~ Weight*Site*Conditions),
  trace = 0,
  direction = "forward",
  k = log(nrow(data_fourmis))
)
summary(modele_q4_sel_forward_bic)
```

### Tidyverse

```{webr}
#| envir: tdv
#| autorun: true
modele_q4_sel_forward_bic <- step(
  object = glm(
    formula = Effectifs ~ 1,
    family = poisson(),
    data = data_fourmis
  ),
  scope = list(upper = Effectifs ~ Weight*Site*Conditions),
  trace = 0,
  direction = "forward",
  k = log(nrow(data_fourmis))
)
summary(modele_q4_sel_forward_bic)
```
:::

**Synth√®se**

On compare les mod√®les s√©lectionn√©s :

::: {.panel-tabset group="language"}
### Base R

```{webr}
#| envir: baser
#| autorun: true
data.frame(
  `M√©thode` = c("Backward", "Backward", "Forward", "Forward"),
  `Crit√®re` = c("AIC", "BIC", "AIC", "BIC"),
  `Formula` = c(
    strsplit(toString(modele_q4_sel_backward_aic$call), ",")[[1]][2],
    strsplit(toString(modele_q4_sel_backward_bic$call), ",")[[1]][2],
    strsplit(toString(modele_q4_sel_forward_aic$call), ",")[[1]][2],
    strsplit(toString(modele_q4_sel_forward_bic$call), ",")[[1]][2]
  ),
  AIC = c(
    AIC(modele_q4_sel_backward_aic),
    AIC(modele_q4_sel_backward_bic),
    AIC(modele_q4_sel_forward_aic),
    AIC(modele_q4_sel_forward_bic)
  ),
  BIC = c(
    BIC(modele_q4_sel_backward_aic),
    BIC(modele_q4_sel_backward_bic),
    BIC(modele_q4_sel_forward_aic),
    BIC(modele_q4_sel_forward_bic)
  )
)
```

### Tidyverse

```{webr}
#| envir: tdv
#| autorun: true
data.frame(
  `M√©thode` = c("Backward", "Backward", "Forward", "Forward"),
  `Crit√®re` = c("AIC", "BIC", "AIC", "BIC"),
  `Formula` = c(
    strsplit(toString(modele_q4_sel_backward_aic$call), ",")[[1]][2],
    strsplit(toString(modele_q4_sel_backward_bic$call), ",")[[1]][2],
    strsplit(toString(modele_q4_sel_forward_aic$call), ",")[[1]][2],
    strsplit(toString(modele_q4_sel_forward_bic$call), ",")[[1]][2]
  ),
  AIC = c(
    AIC(modele_q4_sel_backward_aic),
    AIC(modele_q4_sel_backward_bic),
    AIC(modele_q4_sel_forward_aic),
    AIC(modele_q4_sel_forward_bic)
  ),
  BIC = c(
    BIC(modele_q4_sel_backward_aic),
    BIC(modele_q4_sel_backward_bic),
    BIC(modele_q4_sel_forward_aic),
    BIC(modele_q4_sel_forward_bic)
  )
)
```
:::

On garderait donc le mod√®le g√©n√©ral (celui de la question 3) selon AIC
et le mod√®le le plus simple `Site+Weight` selon le BIC.

:::

:::

## Question 5

L‚Äôincoh√©rence dans les s√©lections backward et forward pr√©c√©dentes sugg√®re qu‚Äôil y a
peut-√™tre un sous-mod√®le alternatif (non test√© par ces algorithmes) encore meilleur.
Cela nous incite √† effectuer une s√©lection exhaustive du meilleur sous-mod√®le, comme
le propose la fonction `regsubsets` en r√©gression lin√©aire. Malheureusement cette
derni√®re ne fonctionne pas avec le mod√®le de Poisson. Si on voulait impl√©menter
cette s√©lection exhaustive nous-m√™me, justifier qu‚Äôil y aurait 30 sous-mod√®les (avec
constante) √† tester, en comptant le mod√®le le plus g√©n√©ral.

::: {.content-visible when-meta="is_answer_print_5"}

::: answer

On peut d√©couper le combinaison de param√©trage pour l'ordonn√©e √†
l'origine et pour la pente associ√©e √† la variable $\texttt{Weight}$. L'ensemble
des combinaisons possibles de sous-mod√®le sera ainsi le produit
cart√©sien de ces deux sous ensembles.

**Choix pour l'ordonn√©e √† l'origine**

Il y a 5 possibilit√©s pour l'ordonn√©e √† l'origine pour un mod√®le avec
une constante.

-   Une constante unique : `1`
-   Une constante par type de for√™t : `Site`
-   Une constante selon les conditions de recueil : `Conditions`
-   Une constante qui additionne l'effet du type de for√™t et les
    conditions de recueil : `Site + Conditions`
-   Une constante par croisement du type de for√™t et conditions de
    recueil : `Site:Conditions`

**Choix pour la pente associ√©e √† la variable $\texttt{Weight}$**

-   Pente nulle qui signifie l'absence d'effet du poids de l'√©chantillon :   `0*Weight`
-   Une pente unique : `Weight`
-   Une pente type de for√™t : `Weight:Site`
-   Une pente selon les conditions de recueil : `Weight:Site`
-   Une pente qui additionne l'effet du type de for√™t et les conditions
    de recueil : `Weight:Site + Weight:Conditions`
-   Une pente par croisement du type de for√™t et conditions de recueil :
    `Weight:Site:Conditions`

Il y a donc $5 \times 6 = 30$ mod√®les possibles.

::: {.callout-note collapse="true"}
### Compl√©ments : Impl√©mentation de la recherche exhaustive

On pourrait impl√©menter soi-m√™me la recherche exhaustive avec quelques
lignes de codes en {{< iconify logos:r-lang >}}. Ce n'est pas imm√©diat et donc pas demand√© dans
l'exercice.

```{webr}
#| envir: baser
#| autorun: true
data_combinaisons <- expand.grid(list(
  constante = c("1", "Site", "Conditions", "Site + Conditions", "Site:Conditions"),
  pente = c("0*Weight", "Weight" ,"Weight:Site", "Weight:Conditions", "Weight:Site + Weight:Conditions", "Weight:Site:Conditions")
))
combinaisons <- paste0(
  "Effectifs ~ ",
  data_combinaisons$constante,
  " + ",
  data_combinaisons$pente
)

lapply(
  X = combinaisons,
  FUN = function(x){
    estimation <-  glm(formula = x, family = poisson(), data = data_fourmis)
    data.frame(formula = x, AIC = AIC(estimation), BIC = BIC(estimation))
  }
) |> do.call(what = rbind.data.frame)
```
:::

:::

:::

## Question 6

On admet qu‚Äô√† l‚Äôissue d‚Äôune telle s√©lection exhaustive, le meilleur sous-mod√®le au
sens de l‚ÄôAIC et du BIC est celui dont les coefficients de $\texttt{Weight}$ sont d√©clin√©s en
autant de modalit√©s crois√©es que contiennent les facteurs $\texttt{Site}$ et
$\texttt{Conditions}$ (c‚Äôest √† dire 8), mais qui a une ordonn√©e √† l‚Äôorigine
identique pour toutes les modalit√©s crois√©es de $\texttt{Site}$ et
$\texttt{Conditions}$. Estimer ce mod√®le, calculer son AIC et son BIC et
comparer avec ceux des mod√®les s√©lectionn√©s pr√©c√©demment.

::: {.content-visible when-meta="is_answer_print_6"}

::: answer

On estime le meilleur mod√®le log-lin√©aire de Poisson au sens du BIC et
de l'AIC.

::: {.panel-tabset group="language"}
### Base R

```{webr}
#| envir: baser
#| autorun: true
modele_q6 <- glm(
  formula = Effectifs ~ Weight:Site:Conditions,
  family = poisson(),
  data = data_fourmis
)
summary(modele_q6)
BIC(modele_q6)
```

### Tidyverse

```{webr}
#| envir: tdv
#| autorun: true
modele_q6 <- glm(
  formula = Effectifs ~ Weight:Site:Conditions,
  family = poisson(),
  data = data_fourmis
)
summary(modele_q6)
BIC(modele_q6)
```
:::

On obtient AIC=1008 et BIC=1036.6, qui sont bien plus faibles que ceux
des mod√®les retenus par s√©lection stepwise.

:::

:::

## Question 7

En guise d‚Äôalternative, nous souhaitons essayer d‚Äôajuster un mod√®le g√©n√©ralis√© binomial
n√©gatif. Si on inclut toutes les interactions possibles, cette approche semble-t-elle
pr√©f√©rable au mod√®le de Poisson ?

::: {.content-visible when-meta="is_answer_print_7"}

::: answer

On adopte la m√™me d√©marche. On estime d'abord le mod√®le avec le plus de
termes. On utilise la fonction `glm.nb` du package `MASS`.

::: {.panel-tabset group="language"}
### Base R

```{webr}
#| envir: baser
#| autorun: true
modele_q7 <- MASS::glm.nb(
  formula = Effectifs ~ Weight*Site*Conditions,
  data = data_fourmis
)
summary(modele_q7)
```

### Tidyverse

```{webr}
#| envir: tdv
#| autorun: true
modele_q7 <- MASS::glm.nb(
  formula = Effectifs ~ Weight*Site*Conditions,
  data = data_fourmis
)
summary(modele_q7)
```
:::

Avec ce mod√®le, l‚Äôinteraction triple semble √©galement significative. On
obtient AIC=992 et BIC=1046, ce qui est inf√©rieur √† l‚ÄôAIC et au BIC du
mod√®le de Poisson avec interaction triple (AIC=1010 et BIC=1061).

Ce r√©sultat est encourageant et nous incite √† chercher le meilleur
sous-mod√®le possible.

:::

:::

## Question 8

Apr√®s une s√©lection exhaustive, on admet que le meilleur sous-mod√®le binomial n√©gatif
au sens de l‚ÄôAIC fait intervenir les m√™mes variables que le meilleur mod√®le de
Poisson. Par contre, pour le crit√®re BIC, il s‚Äôagit du mod√®le ne faisant intervenir que
$\texttt{Weight}$ et $\texttt{Site}$, dans lequel le coefficient de $\texttt{Weight}$
varie selon $\texttt{Site}$, mais l‚Äôordonn√©e
√† l‚Äôorigine est constante. Estimer ces deux mod√®les et calculer leur AIC et BIC.

::: {.callout-note collapse="true"}
### Compl√©ment : Impl√©mentation de la recherche exhaustive

On pourrait √† nouveau impl√©menter soi-m√™me la recherche exhaustive avec
quelques lignes de codes en {{< iconify logos:r-lang >}} pour retrouver le r√©sultat de l'√©nonc√©. Ce
n'est toujours pas imm√©diat.

```{webr}
#| envir: baser
#| autorun: true
lapply(
  X = combinaisons,
  FUN = function(x){
    estimation <-  glm.nb(formula = x, data = data_fourmis)
    data.frame(formula = x, AIC = AIC(estimation), BIC = BIC(estimation))
  }
) |> do.call(what = rbind.data.frame)
```
:::

::: {.content-visible when-meta="is_answer_print_8"}

::: answer

**Mod√®le binomial n√©gatif s√©lectionn√© par l'AIC**

::: {.panel-tabset group="language"}
### Base R

```{webr}
#| envir: baser
#| autorun: true
modele_q8_best_aic <- MASS::glm.nb(
  formula = Effectifs ~ 1 + Weight:Site:Conditions,
  data = data_fourmis
)
summary(modele_q8_best_aic)
BIC(modele_q8_best_aic)
```

### Tidyverse

```{webr}
#| envir: tdv
#| autorun: true
modele_q8_best_aic <- MASS::glm.nb(
  formula = Effectifs ~ 1 + Weight:Site:Conditions,
  data = data_fourmis
)
summary(modele_q8_best_aic)
BIC(modele_q8_best_aic)
```
:::

Son AIC vaut 986 et son BIC 1018.

**Mod√®le binomial n√©gatif s√©lectionn√© par le BIC**

::: {.panel-tabset group="language"}
### Base R

```{webr}
#| envir: baser
#| autorun: true
modele_q8_best_bic <- MASS::glm.nb(
  formula = Effectifs ~ 1 + Weight:Site,
  data = data_fourmis
)
summary(modele_q8_best_bic)
BIC(modele_q8_best_bic)
```

### Tidyverse

```{webr}
#| envir: tdv
#| autorun: true
modele_q8_best_bic <- MASS::glm.nb(
  formula = Effectifs ~ 1 + Weight:Site,
  data = data_fourmis
)
summary(modele_q8_best_bic)
BIC(modele_q8_best_bic)
```
:::

Son AIC vaut 997 et son BIC 1016.

Evidemment l‚ÄôAIC du premier est inf√©rieur √† celui du second, et
inversement pour le BIC.

:::

:::

## Question 9

Etant donn√© l‚Äôavis des experts, il semble important que le mod√®le tienne compte des
conditions d‚Äôhumidit√©. Quel mod√®le final retenir ?

::: {.content-visible when-meta="is_answer_print_9"}

::: answer

Le meilleur mod√®le de Poisson au sens de l‚ÄôAIC et du BIC d√©pend de
`Weight:Site:Conditions`. Il fait donc intervenir les conditions
d‚Äôhumidit√©.

Le meilleur mod√®le binomial n√©gatif au sens de l‚ÄôAIC fait intervenir les
m√™mes variables. Celui au sens du BIC fait intervenir `Weight:Site` et
ne d√©pend pas des conditions.

En comparant, le mod√®le de Poisson avec `Weight:Site:Conditions` et le
mod√®le binomial n√©gatif avec les m√™mes variables : les crit√®res AIC et
BIC nous conduisent tous deux au second choix : le meilleur mod√®le
binomal n√©gatif au sens de l'AIC.

:::

:::

## Question 10

Ecrire l‚Äô√©quation du mod√®le retenu suivant les diff√©rents sites et les conditions de
recueil.

::: {.content-visible when-meta="is_answer_print_10"}

::: answer

Le mod√®le s√©lectionn√© de la variables s'√©crit :

$$
\begin{align*}
\texttt{Effectifs}&|(\texttt{Weight}, \texttt{Site},\texttt{Conditions}) \sim NB(\lambda(\texttt{Weight}, \texttt{Site},\texttt{Conditions}), \theta)
\end{align*}
$$

avec

$$
\begin{align*}
\textrm{log}\left(\lambda(\texttt{Weight}, \texttt{Site},\texttt{Conditions})\right) = &\ \ \ \ \ 
\beta_0 \\ 
&+\beta_{1}\texttt{Weight}\textbf{1}_{\texttt{Site}=\texttt{FLWT}}\textbf{1}_{\texttt{Conditions}=\texttt{Dry}}  \\
&+\beta_{2}\texttt{Weight}\textbf{1}_{\texttt{Site}=\texttt{FTWT}}\textbf{1}_{\texttt{Conditions}=\texttt{Dry}}  \\
&+\beta_{3}\texttt{Weight}\textbf{1}_{\texttt{Site}=\texttt{GPWT}}\textbf{1}_{\texttt{Conditions}=\texttt{Dry}} \\
&+\beta_{4}\texttt{Weight}\textbf{1}_{\texttt{Site}=\texttt{INWT}}\textbf{1}_{\texttt{Conditions}=\texttt{Dry}} \\
&+\beta_{5}\texttt{Weight}\textbf{1}_{\texttt{Site}=\texttt{FLWT}}\textbf{1}_{\texttt{Conditions}=\texttt{Wet}}  \\
&+\beta_{6}\texttt{Weight}\textbf{1}_{\texttt{Site}=\texttt{FTWT}}\textbf{1}_{\texttt{Conditions}=\texttt{Wet}}  \\
&+\beta_{7}\texttt{Weight}\textbf{1}_{\texttt{Site}=\texttt{GPWT}}\textbf{1}_{\texttt{Conditions}=\texttt{Wet}} \\
&+\beta_{8}\texttt{Weight}\textbf{1}_{\texttt{Site}=\texttt{INWT}}\textbf{1}_{\texttt{Conditions}=\texttt{Wet}} \\
\end{align*}
$$

On estime que $\theta$ par $\hat{\theta}\approx 16,25$

On peut repr√©senter les estimations de
$\lambda(\texttt{Weight}, \texttt{Site},\texttt{Conditions})$ dans un
tableau √† double entr√©e.

|   | $\texttt{Conditions}=\texttt{"Dry"}$ | $\texttt{Conditions}=\texttt{"Wet"}$ |
|------------------------|------------------------|------------------------|
| $\texttt{Site}=\texttt{"FLWT"}$ | $\exp(1.761+0.101\texttt{Weight})$ | $\exp(1.761+0.099\texttt{Weight})$ |
| $\texttt{Site}=\texttt{"FTWT"}$ | $\exp(1.761+0.048\texttt{Weight})$ | $\exp(1.761+0.010\texttt{Weight})$ |
| $\texttt{Site}=\texttt{"GPWT"}$ | $\exp(1.761+0.034\texttt{Weight})$ | $\exp(1.761+0.048\texttt{Weight})$ |
| $\texttt{Site}=\texttt{"INWT"}$ | $\exp(1.761+0.063\texttt{Weight})$ | $\exp(1.761+0.109\texttt{Weight})$ |

: Estimations de
$\lambda(\texttt{Weight}, \texttt{Site},\texttt{Conditions})$

:::

:::

## Question 11

D‚Äôapr√®s le mod√®le s√©lectionn√©, quelle est la probabilit√© d‚Äôobserver plus de 15 esp√®ces
sur un sol de type $\texttt{INWT}$ par temps sec, bas√© sur un √©chantillon de terre qui p√®se
10 kg ? M√™me question si le temps est humide.

::: {.content-visible when-meta="is_answer_print_11"}

::: answer

On r√©alise une pr√©diction pour 
$\texttt{Weight}=10$, $\texttt{Site}=\textrm{"}\texttt{INWT}\textrm{"}$
et $\texttt{Conditions}=\textrm{"}\texttt{Dry}\textrm{"}$
afin d'obtenir les valeur de la moyenne $\lambda$ de
la loi binomiale n√©gative avec la fonction `predict`.

La probabilit√© d‚Äôobserver plus de 15 esp√®ces s‚Äôobtient ensuite gr√¢ce √†
la fonction de r√©partition d‚Äôune loi binomiale n√©gative sous {{< iconify logos:r-lang >}} (fonction
`pnbinom`) dans laquelle $\lambda$ joue le r√¥le de la moyenne $\mu$ et
$\theta$ joue le r√¥le de la taille d‚Äô√©chantillon `size`.

::: {.panel-tabset group="language"}
### Base R

```{webr}
#| envir: baser
#| autorun: true
lambda <- predict(
  object = modele_q8_best_aic,
  newdata = data.frame(Site="INWT",Conditions="Dry",Weight=10),
  type = "response"
)
1-pnbinom(q = 14, size = modele_q8_best_aic$theta, mu = lambda)
```

### Tidyverse

```{webr}
#| envir: tdv
#| autorun: true
lambda <- predict(
  object = modele_q8_best_aic,
  newdata = data.frame(Site="INWT",Conditions="Dry",Weight=10),
  type = "response"
)
1-pnbinom(q = 14, size = modele_q8_best_aic$theta, mu = lambda)
```
:::

Cette probabilit√© est de 0.19.

Pour $\texttt{Weight}=10$, $\texttt{Site}=\textrm{"}\texttt{INWT}\textrm{"}$
et $\texttt{Conditions}=\textrm{"}\texttt{Wet}\textrm{"}$,

::: {.panel-tabset group="language"}
### Base R

```{webr}
#| envir: baser
#| autorun: true
lambda <- predict(
  object = modele_q8_best_aic,
  newdata = data.frame(Site="INWT",Conditions="Wet",Weight=10),
  type = "response"
)
1-pnbinom(q = 14, size = modele_q8_best_aic$theta, mu = lambda)
```

### Tidyverse

```{webr}
#| envir: tdv
#| autorun: true
lambda <- predict(
  object = modele_q8_best_aic,
  newdata = data.frame(Site="INWT",Conditions="Wet",Weight=10),
  type = "response"
)
1-pnbinom(q = 14, size = modele_q8_best_aic$theta, mu = lambda)
```
:::

La probabilit√© est de 0.66.

:::

:::